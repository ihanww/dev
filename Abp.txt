
aspnetboilerplate
https://aspnetboilerplate.com/Pages/Documents
https://aspnetboilerplate.com/Pages/Documents/Zero/Identity-Server
https://aspnetboilerplate.com/Pages/Zero/Identity-Server-vNext


aspnetboilerplate-cn
https://www.52abp.com/Wiki/abp-cn/latest/



abpframework
https://docs.abp.io/zh-Hans/abp/latest
https://docs.abp.io/zh-Hans/abp/latest/Modules/IdentityServer


ABP VNext学习日记 & ASP.NET Core学习日记
https://sheng.blog.csdn.net/article/details/109006014


https://github.com/WilliamXu96/ABP-MicroService
ABP-MicroService项目功能
解析：
[1]租户管理：对系统租户进行管理，可新增和修改租户，租户数据自动隔离
[2]用户管理：提供用户相关配置
[3]角色管理：对系统菜单权限进行分配
[4]组织机构：可配置系统组织架构，树形展示、级联查询
[5]字典管理：用于维护常用一些固定的数据，比如状态、性别等
[6]岗位管理：配置各个部门的职位
[7]操作日志：记录用户操作日志与异常日志，方便开发人员定位排错
[8]表单管理：可动态拖拽生成系统表单
[9]后台作业：HangFire后台工作者
[10]存储管理：管理用户上传的静态文件
[11]代码生成：基于动态表单生成后台代码



重新整理 .net core 实践篇
https://www.cnblogs.com/aoximin/category/1642785.html?page=2

工程结构概览：定义应用分层及依赖关系
https://time.geekbang.org/course/detail/100044601-198256

课件和 Demo 地址
https://gitee.com/geektime-geekbang/NET-Core

Entity Framework Core
https://learn.microsoft.com/zh-cn/ef/core/

WebApiClient
https://github.com/dotnetcore/WebApiClient


//----------------------------------------------------------------------


aspnetboilerplate
https://github.com/aspnetboilerplate
https://github.com/aspnetboilerplate/aspnetboilerplate-samples
https://github.com/aspnetboilerplate/aspnetboilerplate-templates
https://github.com/aspnetboilerplate/aspnet-core-template    aspnetboilerplate-core-template


abpframework
https://github.com/WangJunZzz/abp-vnext-pro.git
https://github.com/colinin/abp-next-admin.git
https://github.com/52ABP/YoYoCms.AbpProjectTemplate.git
https://github.com/xiajingren/HelloAbp.git


https://github.com/WilliamXu96/ABP-MicroService.git   abp-microservice
https://github.com/abpframework/eShopOnAbp.git

https://github.com/abpframework/abp.git
https://github.com/abpframework/abp-samples
https://github.com/EasyAbp/awesome-abp.git





//----------------------------------------------------------------------

https://www.52abp.com/Wiki/abp-cn/latest/
ABP 中文文档


Abp.AspNetCore是ASP.NET Core的一个开源框架，它提供了一系列的工具和组件，
使得开发人员可以更加高效地开发ASP.NET Core应用程序。
该框架基于ABP框架，提供了多租户、多语言、权限管理、缓存、日志等功能。

Abp.ZeroCore是在Abp.AspNetCore基础上进行开发的，它是一个模板项目，
包括了Abp.AspNetCore框架以及Abp.Zero（一个基于ABP框架的身份验证和授权系统）。
使用Abp.ZeroCore可以快速创建一个基于ASP.NET Core的多租户Web应用程序，
并且具有基本的身份验证和授权功能，包括用户管理、角色管理、权限管理等。


ABP框架已实现了以下特性：

* 多语言/本地化支持
* 多租户支持（每个租户的数据自动隔离，业务模块开发者不需要在保存和查询数时写相应代码）
* 软删除支持（继承相应的基类或实现相应接口，会自动实现软删除）
* 统一的异常处理（应用层几乎不需要处理自己写异常处理代码）
* 数据有效性验证（Asp.NET MVC只能做到Action方法的参数验证，ABP实现了Application层方法的参数有效性验证）
* 日志记录（自动记录程序异常）
* 模块化开发（每个模块有独立的EF DbContext，可单独指定数据库）
* Repository仓储模式（已实现了Entity Framework、NHibernate、MangoDB、内存数据库）
* Unit Of Work工作单元模式（为应用层和仓储层的方法自动实现数据库事务）
* EventBus实现领域事件(Domain Events)
* DLL嵌入资源管理
* 通过Application Services自动创建Web Api层（不需要写ApiController层了）
* 自动创建Javascript 的代理层来更方便使用Web Api
* 封装一些Javascript 函数，更方便地使用ajax、消息框、通知组件、忙状态的遮罩层


“Zero”的模块，实现了以下功能：

* 身份验证与授权管理（通过ASP.NET Identity实现的）
* 用户&角色管理
* 系统设置存取管理（系统级、租户级、用户级，作用范围自动管理）
* 审计日志（自动记录每一次接口的调用者和参数）

在其他项目中的很多优秀设计，在ABP项目中也已存在，而且可能实现得更好。
ABP框架的代码，都通过xUnit进行了单元测试。
作者一直在用ABP框架开发他们的实际项目，从Github和他官方论坛上的信息可以看到，
有很多国外的开发者在将ABP用作生产项目的基础框架。
如果需要直接使用ABP组件，可以通过Nuget安装（在VS的Nuget包管理界面搜索ABP）。


ABP - 调试

虽然这个功能通常不需要，但是当你调试你的项目的时候，你可能需要进入 ABP 的源代码。

所有官方的 ABP nuget packages 都开启了Sourcelink。
这就是说你可以在你的项目中很方便的调试 Abp. nuget packages。
为了开启该功能，你需要像下面一样来设置你的 Visual Studio (2017+) 调试选项。

1.调试 >> 常规 >> 启用"仅我的代码"
2.调试 >> 常规 >> 启用源服务器支持



//----------------------------------------------------------------------

ABP总体介绍 - 多层架构

前言

应用程序代码库的分层是一种广泛接受的技术，有助于降低复杂性并提高代码的可重用性。
为了实现分层体系结构，ASP.NET Boilerplate遵循域驱动设计的原则。


领域驱动设计（DDD）中有四个基本层：

展现层(Presentation)：向用户提供一个接口(UI)，使用应用层来和用户(UI)进行交互。

应用层(Application)：应用层是表现层和领域层能够实现交互的中间者，协调业务对象去执行特定的应用任务

领域层(Domain)：包括业务对象和业务规则，这是应用程序的核心层。

基础设施层(Infrastructure)：提供通用技术来支持更高的层。
例如基础设施层的仓储(Repository)可通过ORM来实现数据库交互，或者提供发送邮件的支持。


根据实际需要，可能会有额外添加的层。例如：
分布式服务层(Distributed Service) ：用于公开应用程序接口供远程客户端调用。比如通过ASP.NET Web API或WCF来实现。
这些都是常见的以领域为中心的分层体系结构。不同的项目在实现上可能会有细微的差别。


//----------------------------------------------------------------------

ASP.NET Boilerplate应用程序体系结构模型

除了DDD之外，现代架构应用程序中还有其他逻辑层和物理层。为ASP.NET Boilerplate应用程序建议并实现了以下模型。
ASP.NET Boilerplate不仅通过提供基类和服务来简化实现此模型，还提供了直接从此模型开始的启动模板。


客户应用
这些是通过HTTP API（API控制器，OData控制器，甚至可能是GraphQL端点）将应用程序用作服务的远程客户端。
远程客户端可以是SPA（单页面应用程序），移动应用程序或第三方消费者。可以在此应用程序内完成本地化和导航栏。

表现层
ASP.NET [Core] MVC（模型 - 视图 - 控制器）可以被认为是表现层。
它可以是物理层（通过HTTP API使用应用程序）或逻辑层（直接注入和使用应用程序服务）。
在任何一种情况下，它都可以包括 本地化 ，导航栏， 对象映射，缓存， 配置管理，审计日志记录等。
它还涉及 授权验证，会话， 功能（用于 多租户应用程序）和异常处理。

分布式服务层
该层用于通过REST，OData，GraphQL等远程API提供应用程序/领域功能......
它们不包含业务逻辑，只是将HTTP请求转换为领域交互，或者可以使用应用程序服务来委派操作。
该层通常包括授权验证，缓存， 审计日志记录，对象映射，异常处理，会话等...

应用层
应用层主要包括应用程序服务的使用领域层和领域对象（领域服务， 实体 ...）来执行请求的应用程序的功能。
它使用数据传输对象从表示或分布式服务层获取数据并将数据返回。
它还可以处理 授权验证，缓存，审计日志记录，对象映射，会话等...

领域层
这是实现我们的域逻辑的主要层。它包括 实体，值对象和领域服务，以执行业务/领域逻辑。
它还可以包括规约和触发 领域事件。它定义了仓储接口，以便从数据源（通常是DBMS）读取和保留实体。

基础设施层
基础结构层使其他层工作：它实现仓储接口以实际使用真实数据库。它还可能包括与供应商集成以邮件发送等。
该层不强制所有高层都需要直接实现或引用（并非所有层的下层），但实际上通过实现它们的抽象概念来支持其他层。


//----------------------------------------------------------------------


[DependsOn(typeof(InvokeModule), typeof(EventModule))]
public class AimpModule : AppModule<DefaultDbContext, InvokeDbContext>



ABP 总体介绍 - 模块系统

1.ABP 模块系统简介

ASP.NET Boilerplate提供了构建模块的基础结构，并将它们组合在一起以创建应用程序。
模块可以依赖于另一个模块。通常，组件被视为模块。
如果创建具有多个程序集的应用程序，建议您为每个程序集创建一个模块定义。

模块系统当前专注于服务端而不是客户端。

名词解释 : Assembly

程序集：Assembly 是一个用来包含程序的名称，版本号，自我描述，文件关联关系和文件位置等信息的一个集合。
最简单的理解就是：一个你自己写的类库生成的 dll 就可以看做是一个程序集，这个程序集可以包括很多类，类又包括很多方法等。


2.定义模块

一个派生自 AbpModule 的类就是模块的定义。
假设我们正在开发一个可以在不同应用程序中使用的Blog模块。
最简单的模块定义如下所示：

public class MyBlogApplicationModule : AbpModule //定义
{
    public override void Initialize() //初始化
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
        //这行代码的写法基本上是不变的。它的作用是把当前程序集的特定类或接口注册到依赖注入容器中。
    }
}

如果需要，模块定义类负责通过依赖注入来注册它的类 （它可以按常规方式完成，如上所示）。
它还可以配置应用程序和其他模块，为应用程序添加新功能，等等......


3.生命周期方法

ASP.NET Boilerplate在应用程序启动和关闭时调用某些特定的模块方法。
您可以覆盖这些方法以执行某些特定任务。

ABP 框架通过依赖关系的顺序来调用这些方法，
假如：模块 A 依赖于模块 B,那么模块 B 要在模块 A 之前初始化，模块启动的方法顺序如下：

PreInitialize-B
PreInitialize-A
Initialize-B
Initialize-A
PostInitialize-B
PostInitialize-A

下面是具体方法的说明：

PreInitialize 预初始化

这个方法是模块配置阶段，通常在这个方法里进行模块的预配置，如配置依赖注入、添加自定义的实现类等。
它在依赖项之前运行，通常在这个阶段不要解析（resolve）任何服务，因为它们可能还未初始化。

当应用程序启动时，首先调用此方法。它是在初始化之前配置框架和其他模块的首选方法。
在依赖注入注册之前，你可以在这个方法中指定你需要注入的自定义启动类。

例如：加入你创建了某个符合约定的注册类，你应该使用 IocManager.AddConventionalRegisterer 方法在这里注册它。


Initialize 初始化

这个阶段是模块初始化阶段，主要是为定义类型（如实体、仓储接口等）添加依赖关系。
在这个阶段，还可以解析一些已在PreInitialize阶段注册的服务。

在这个方法中一般是来进行依赖注入的注册，一般我们通过 IocManager.RegisterAssemblyByConvention 这个方法来实现。
如果你想实现自定义的依赖注入，那么请参考依赖注入的相关文档。


PostInitialize 初始化后

最后一个方法，这个方法用来解析依赖关系。

这个阶段在所有模块的Initialize方法执行完之后执行，用于解析或开始使用已初始化的服务。
在这个阶段，所有的服务都应该已经注册并准备好被解析和使用。


Shutdown 关闭

关闭：当应用关闭以后，这个方法被调用。


4.模块依赖

Abp 框架会自动解析模块之间的依赖关系，但是我们还是建议使用DependsOn属性显式声明依赖项，
如下所示：

[DependsOn(typeof(MyBlogCoreModule))] //通过注解来定义依赖关系
public class MyBlogApplicationModule : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}

例如上面的代码，我们就声明了 MyBlogApplicationModule 和 MyBlogCoreModule 的依赖关系，
MyBlogApplicationModule 这个应用模块依赖于 MyBlogCoreModule 核心模块，
并且，MyBlogCoreModule 核心模块会在 MyBlogApplicationModule 模块之前进行初始化。

ABP 可以从 startup module 递归的解析依赖关系，并按需初始化它们。
最后初始化的模块是启动模块(startup module)。


5.插件模块

当模块从启动模块以及其依赖关系进行调查发现的时候，ABP 也能够动态的加载其它指定模块。
AbpBootstrapper 类定义了 PlugInSources 属性，我们能用该属性添加需要动态加载的模块。
插件源可以是任何实现了 IPlugInSource 接口的类。
FolderPlugInSource 类实现了该接口，它可以被用来加载指定文件夹下的程序集。

ASP.NET Core

ABP 的 ASP.NET Core 模块也可以动态加载模块，
你只需要在 Startup 类中使用已定义的扩展方法 AddAbp，如下所示：

services.AddAbp<MyStartupModule>(options =>
{
    options.PlugInSources.Add(new FolderPlugInSource(@"C:\MyPlugIns"));
});

我们可以使用扩展方法 AddFolder 更方便的实现上述功能：

services.AddAbp<MyStartupModule>(options =>
{
    options.PlugInSources.AddFolder(@"C:\MyPlugIns");
});


6.自定义的模块方法

我们自己定义的模块中可能有方法被其他依赖于当前模块的模块调用，
下面的例子，假设模块 2 依赖于模块 1，并且想在预初始化的时候调用模块 1 的方法。
这样，就把模块 1 注入到了模块 2，因此，模块 2 就能调用模块 1 的方法了。

译者注： ABP 的模块系统与 Orchard 的模块有类似之处，但还是有比较大的差别。
Orchard 的框架修改了 ASP.NET 程序集的默认加载方式，实现了功能模块的热插拔
（模块的 DLL 没有放在 Bin 文件夹下，是放在 WEB 项目根文件夹下面的 Modules 文件夹下），
而 ABP 的模块程序集还是放在 Bin 文件夹下的，没有实现热插拔。

public class MyModule1 : AbpModule
{
    public override void Initialize() //初始化模块
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly()); //这里，进行依赖注入的注册。
    }

    public void MyModuleMethod1()
    {
        //这里写自定义的方法。
    }
}

[DependsOn(typeof(MyModule1))]
public class MyModule2 : AbpModule
{
    private readonly MyModule1 _myModule1;

    public MyModule2(MyModule1 myModule1)
    {
        _myModule1 = myModule1;
    }

    public override void PreInitialize()
    {
        _myModule1.MyModuleMethod1(); //调用MyModuleMethod1的方法。
    }

    public override void Initialize()
    {
            IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
     }
}

在这里，我们通过构造函数注入 MyModule1 到 MyModule2，所以 MyModule2 能够调用 MyModule1 的自定义方法。
当且仅当 MyModule2 依赖于 MyModule1 才是可能的。


7.模块配置

虽然自定义模块可以被用来配置模块，但是，作者建议使用启动配置来定义和配置模块。


8.模块生命周期

所有的模块类都被自动的注册为单例模式。


//----------------------------------------------------------------------


ABP总体介绍 - 启动配置

在应用启动之前，abp框架提供了模块基本的配置和方法，大家参照下面这个例子就可以了。
译者注： 在看这一节的内容之前，建议大家先下载module-zero这个例子代码，这个例子就是一个用户和角色的模块，并且使用的实例。
配置在每一个应用中都可能会有，比如你有一个网站，你要获取网站的一些自定义基本参数，比如logo位置，网站名称，上传文件大小等等。
模块化的配置方式和我们之前的做法肯定是不同的，大家要注意。之前无非就是一个方法getConfig从对应的表取数据，然后使用。

1.配置ABP

配置是通过在自己模块的PreInitialize方法中来实现的
（对于module的PreInitialize方法，在上一篇中已经向大家做了简单的说明）代码示例如下：

public class SimpleTaskSystemModule : AbpModule
{
    public override void PreInitialize()
    {
        //在你的应用中添加语言包，这个是英语和作者的土耳其语。
        Configuration.Localization.Languages.Add(new LanguageInfo("en", "English", "famfamfam-flag-england", true));
        Configuration.Localization.Languages.Add(new LanguageInfo("tr", "Türkçe", "famfamfam-flag-tr"));

        Configuration.Localization.Sources.Add(
            new XmlLocalizationSource(
                "SimpleTaskSystem",
                HttpContext.Current.Server.MapPath("~/Localization/SimpleTaskSystem")
                )
            );

        //配置导航和菜单
        Configuration.Navigation.Providers.Add<SimpleTaskSystemNavigationProvider>();
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}

和orchard类似，abp框架一开始就被设计成模块化的，不同的模块可以通过abp框架来进行配置。
举个例子吧，不同的模块都可以添加导航，通过导航添加菜单项到自己定义的主菜单，具体的细节大家可以参照：


替换内置服务

Configuration.ReplaceService 方法可以被用来重写某个内置的服务。
例如，你可以替换掉IAbpSession服务使用你自己扩展的服务。如下所示：

Configuration.ReplaceService<IAbpSession, MySession>(DependencyLifeStyle.Transient);

ReplaceService 方法通过传递一个 Action 来实现替换，这样我们就可以使用自定义的扩展类型替换掉原来的类型
(你也可以直接使用Castle Windsor直接调用更高级的API函数)。

同一个服务可以被替换多次(尤其是在不同的模块)。最后替换的类型才是最终的使用类型。


2.配置模块

和.net框架原生的启动配置相比较，abp有哪些不一样呢？
abp框架的模块可以通过IAbpModuleConfigurations接口进行个性化的扩展，这样的话，模块配置更加简单、方便。

示例代码如下：

...
using Abp.Web.Configuration;
...
public override void PreInitialize()
{
    Configuration.Modules.AbpWebCommon().SendAllExceptionsToClients = true;
}
...

在上面这个例子中，我们通过配置AbpWebCommon模块，发送异常到客户端。
当然了，不是每一个模块都需要这种配置，通常情况下我们需要，是当一个模块需要在多个不同的应用中重复使用，我们才进行这样的配置。


3.为一个模块创建配置

如下代码，假如我们有一个命名为MyModule的模块，并且这各模块有一些自己的配置。
那么我们首先要创建一些类，这些类定义为属性（译者注：属性有自动的get和set访问器。），代表了不同的配置。

public class MyModuleConfig
{
    public bool SampleConfig1 { get; set; }

    public string SampleConfig2 { get; set; }
}

接下来，我们通过依赖注入，注册这个类 IocManager.Register();

译者注： 在IocManager中注册了一个类，换句话说，我们通过IocManager可以得到这个类MyModuleConfig的实例。
至于IOC的原理这里就不在详细说了，总之，就是可以得到一个类的实例。

最后，我们通过创建一个扩展的方法IModuleConfigurations来得到配置的引用。
如下代码：

public static class MyModuleConfigurationExtensions
{
    public static MyModuleConfig MyModule(this IModuleConfigurations moduleConfigurations)
    {
        return moduleConfigurations.AbpConfiguration.Get<MyModuleConfig>();
    }
}

译者注： 模块配置是一个静态类，因为我们需要重复使用它。
静态方法Mymodule返回的是一个配置接口，参数是IModuleConfigurations接口。

现在，在其他模块中也可以配置我们自定义的这个MyModule模块了。 

Configuration.Modules.MyModule().SampleConfig1 = false; 
Configuration.Modules.MyModule().SampleConfig2 = "test";


使用注入进行配置
在某些时候，MyModule 需要此配置。您可以注射 MyModuleConfig 并使用配置的值。例：

public class MyService : ITransientDependency
{
    private readonly MyModuleConfig _configuration;

    public MyService(MyModuleConfig configuration)
    {
        _configuration = configuration;
    }

    public void DoIt()
    {
        if (_configuration.SampleConfig2 == "test")
        {
            //...
        }
    }
}

这意味着，在abp框架的系统中，所有的模块都可以集中配置。


//----------------------------------------------------------------------

ABP总体介绍 - 多租户

1.什么是多租户

维基百科：

“软件多租户是指一个软件架构的实例软件运行在一个服务器上，但存在多个租户。
租户是一组共享一个公共的用户访问特定权限的软件实例。
多租户架构,软件应用程序旨在提供每个租户专用的实例包括数据、配置、用户管理、租户个体功能和非功能属性。
多租户与多实例架构,独立的软件实例代表不同的租户”

操作多租户一般用来创建SaaS(软件即服务）应用程序（云计算）：
简而言之，多租户是一种用于创建SaaS （软件即服务）应用程序的技术。


2.多个部署多个数据库

这实际上并不是多租户，如果为每个客户（租户）配置一个单独的数据库和应用程序的一个实例，
即在单个服务器中部署但提供给多个客户(租户)使用，我们需要确保应用程序的多个实例不会因为系统相同的配置环境而发生冲突。
这种已有的设计方式也不是真正为多租户服务的，它的好处是更容易的创建，但是存在一些安装、使用和维护的问题。


3.单个部署多个数据库

使用这种方式，我们可以在服务器上运行应用程序的一个实例。
我们有一个主数据库用来存储租户的数据(例如：租户名称以及子域名)以及每个租户的单个数据库。
一旦我们识别出当前租户(例如：从子域名或者用户登录的信息来判定)，那么我们可以切换到当前租户的数据库来执行操作。

以这种方式设计出来的应用程序，在某种程度上可以被看做多租户。但是大多数的应用仍然依赖于多租户。

我们应该为每个租户创建和维护它们自己单独的数据库，这包括数据迁移。
如果我们有很多的客户以及与之相应的数据库，在更新应用程序的时候，那会花费太多的时间在数据库架构的迁移上。
当然这样做，我们为租户分离出了数据库，我们可以为每个租户备份它们自己的数据库。
如果租户需要的话，我们可以将租户的数据库迁移到更强大的服务器上。


4.单个部署单个数据库

这是真正的多租户构架，我们只在服务器上部署应用程序的单一实例且只有一个数据库。
在各表中使用TenantId来隔离其它租户的信息。

这样的好处是易于安装和维护，但创建这样的一个应用程序比较困难。因为，需要防止租户读写其它租户的信息。
在用户读取数据时候可以添加TenantId过滤器过滤数据，同样，系统会检测用户的写入操作。
这是很繁琐的，而且也容易出错。ABP可以帮助我们自动数据过滤。

如果我们有很多租户并且数据量巨大，那么这种实现方式将会导致一些性能问题。
我们可以使用表分区或者数据库的其它功能来克服这些问题。


5.单部署混合数据库

通常我们可能想存储租户到一个单独的数据库中，但是也可能想为租户创建分离的数据库。
例如：我们可以为那些数据量巨大的租户创建单独的数据库，但是其它租户仍使用同一个数据库。


6.多部署-单/多/混合数据库

最后，为了达到更好的性能，高可用性以及伸缩性；
我们可能想要部署我们的应用到多个服务器上。
这些都是依赖于数据库的方式。


7.ABP中的多租户

ABP可以工作于所有上面所描述的场景。

7.1.开启多租户

默认多租户是被禁用的，我们需要在模块的 PreInitialize 方法中开启它，如下所示：
Configuration.MultiTenancy.IsEnabled = true;

7.2.Host VS 租户 宿主与租户

首先，我们先定义两个多租户系统中的术语：

租户：客户有它自己的用户,角色,权限,设置…并使用应用程序与其他租户完全隔离。
多租户应用程序将有一个或多个租户。
如果这是一个CRM应用程序,不同的租户也他们自己的帐户、联系人、产品和订单。
所以,当我们说一个租户的用户,我们的意思是用户拥有的租户。

Host: Host是单例的（只有唯一一个Host).Host负责创建和管理租户。
所以Host用户独立与租户且可以控制租户。

7.3.Session

ABP定义IAbpSession接口来获取当前用户和租户id。这个接口中使用多租户当前租户的id。
因此,它可以基于当前租户的id过滤数据。

这里有一些规则：

如果两个用户id和TenantId是null，那么当前用户没有登录到系统中。
所以，我们不知道这是一个主机用户或租户的用户。在这种情况下，用户不能访问授权的内容。

用户id(如果不为空，TenantId为空的，然后我们可以知道当前用户是一个主机用户。
用户id(如果不为空，TenantId也不为空，我们可以知道当前用户是一个租户的用户。

有关更多的Session内容可查看：Session


//----------------------------------------------------------------------


ABP 依赖注入框架

有许多依赖注入框架，都可以自动解决依赖关系。他们可以创建所有依赖项(递归地依赖和依赖关系)。
所以你只需要依赖注入模式写类和类构造函数&属性，其他的交给DI框架处理！
在良好的应用程序中，类甚至独立于DI框架。整个应用程序只会有几行代码或类，显示的与DI框架交互。

ABP的依赖注入基于 Castle Windsor框架。Castle Windsor 最成熟的DI框架之一。
还有很多这样的框架，如：Unity，Ninject，StructureMap，Autofac等等。

在使用一个依赖注入框架时，首先注册你的接口/类到依赖注入框架中，然后你就可以resolve一个对象。
在Castle Windsor，它是这样的：

var container = new WindsorContainer();

container.Register(
    Component.For<IPersonRepository>().ImplementedBy<PersonRepository>().LifestyleTransient(),
    Component.For<IPersonAppService>().ImplementedBy<PersonAppService>().LifestyleTransient()
);

var personService = container.Resolve<IPersonAppService>();
personService.CreatePerson("Yunus Emre", 19);


我们首先创建了WindsorContainer。然后注册PersonRepository 和 PersonAppService及它们的接口。
然后我们要求容器创建一个IPersonAppService实例。它创建PersonAppService对象及其依赖项并返回。
在这个简单的示例中，使用DI框架也许不是那么简洁，但想象下，在实际的企业应用程序中你会有很多类和依赖关系。
当然，注册的依赖项只在程序启动的某个地方创建一次。

请注意，我们只是将对象声明为临时对象(transient)。
这意味着每当我们创建这些类型的一个对象时，就会创建一个新的实例。
在这里会有许多不同的生命周期(如：Singletion单例模式)。


ABP依赖注入的基础结构
在编写应用程序时遵循最佳实践和一些约定，ABP几乎让依赖注入框架使用变得无形。

注册(Registering)
在ABP中，有很多种不同的方法来注册你的类到依赖注入系统。大部分时间，常规方法就足够了。

常规注册(Conventional registrations)
按照约定，ABP自动注册所有 Repositories， Domain Services， Application Services， MVC 控制器和Web API控制器。
例如，你可能有一个IPersonAppService 接口和实现类PersonAppService：


public interface IPersonAppService : IApplicationService
{
    //...
}

public class PersonAppService : IPersonAppService
{
    //...
}

ABP会自动注册它，因为它实现IApplicationService接口(它只是一个空的接口)。它会被注册为transient (每次使用都创建实例)。
当你注入(使用构造函数注入)IPersonAppService接口成一个类，PersonAppService对象会被自动创建并传递给构造函数。

注意：命名约定在这里非常重要。

例如你可以将名字PersonAppService改为 MyPersonAppService或另一个包含“PersonAppService”后缀的名称，
由于IPersonAppService包含这个后缀。但是你可以不遵循PeopleService命名你的服务类。
如果你这样做，它将不会为IPersonAppService自动注册(它需要自注册（self-registration）到DI框架，而不是接口)，
所以，如果你想要你应该手动注册它。

ABP按照约定注册程序集。所以，你应该告诉ABP按照约定注册你的程序集。这很容易:

IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());

Assembly.GetExecutingAssembly()得到一个对包括此代码的程序集的引用。
你可以通过RegisterAssemblyByConvention方法注册其他程序集。
这同在你的模块初始化（AbpModule.Initialize()）时完成。
请查看ABP的模块系统获得更多信息。

你可以通过实现 IConventionalRegisterer 接口和调用 IocManager.AddConventionalRegisterer 方法编写自己的约定注册类。
你应该将它添加到模块的pre-initialize方法中。

帮助接口(Helper interfaces)
你可以注册一个特定的类，不遵循传统的约定制度规则。
ABP提供了 ITransientDependency和ISingletonDependency 接口的快速实现方法。
例如：

public interface IPersonManager
{
    //...
}

public class MyPersonManager : IPersonManager, ISingletonDependency
{
    //...
}

以这种方式，你可以很容易地注册MyPersonManager。
当需要注入IPersonManager时，MyPersonManager会被使用。注意，依赖被声明为单例。
因此，创建的MyPersonManager同一个对象被传递给所有需要的类。
只是在第一次使用时创建，那么应用程序的整生命周期使用的是同一实例。

自定义/直接 注册(Custom/Direct registration)
如果之前描述的方法还是不足以应对你的情况，你可以使用 IocManager 或者 Castle Windsor 来注册你自己的类。

使用IocManager
你可以使用 IocManager 来注册依赖关系(这通常是在模块的PreInitialize方法中实现)：

IocManager.Register<IMyService, MyService>(DependencyLifeStyle.Transient);

使用Castle Windsor API
你也可以使用 IIocManager.IocContainer 属性来访问Windsor容器并且注册依赖关系。如下所示：

IocManager.IocContainer.Register(Classes.FromThisAssembly()
    .BasedOn<IMySpecialInterface>()
    .LifestylePerThread()
    .WithServiceSelf());


这里没有删除之前实现IWindsorInstaller接口的翻译，因为我感觉这个非常有用。

也可以实现IWindsorInstaller接口进行注册。你可以在应用程序中创建一个实现IWindsorInstaller接口的类：

public class MyInstaller : IWindsorInstaller
{
    public void Install(IWindsorContainer container, IConfigurationStore store)
    {
        container.Register(Classes.FromThisAssembly().
            BasedOn<IMySpecialInterface>().
            LifestylePerThread().
            WithServiceSelf());
    }
}

Abp自动发现和执行这个类。
最后，你可以通过使用IIocManager.IocContainer属性得到WindsorContainer。

解析（Resolving）
注册通知IOC(控制反转)容器关于你的类，它们的依赖项和生命周期。
在你的应用程序需要使用IOC容器创建对象时，ASP.NET提供了一些方法解决依赖关系。

构造函数 & 属性注入(Constructor & Property Injection)
作为最佳实践，应该使用构造函数和属性注入去获取类的依赖。例子：

public class PersonAppService
{
    public ILogger Logger { get; set; }

    private IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
        Logger = NullLogger.Instance;
    }

    public void CreatePerson(string name, int age)
    {
        Logger.Debug("Inserting a new person to database with name = " + name);
        var person = new Person { Name = name, Age = age };
        _personRepository.Insert(person);
        Logger.Debug("Successfully inserted!");
    }
}

IPersonRepository从构造函数注入，ILogger实例从公共属性注入。
这样，你的代码不会体现依赖注入系统。这是使用DI系统最适当的方式。

IIocResolver，IIocManager以及IScopedIocResolver接口

有时可能需要直接创建所需的依赖项，而不是构造函数和属性注入（应该尽可能避免这种情况）。
Abp提供一些服务使得这样的注入很容易实现。例子：

public class MySampleClass : ITransientDependency
{
    private readonly IIocResolver _iocResolver;

    public MySampleClass(IIocResolver iocResolver)
    {
        _iocResolver = iocResolver;
    }

    public void DoIt()
    {
        //解析, 使用并手动释放
        var personService1 = _iocResolver.Resolve<PersonAppService>();
        personService1.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        _iocResolver.Release(personService1);

        //解析并使用using语法糖来释放资源
        using (var personService2 = _iocResolver.ResolveAsDisposable<PersonAppService>())
        {
            personService2.Object.CreatePerson(new CreatePersonInput { Name = "Yunus", Surname = "Emre" });
        }
    }
}

MySampleClass是一个应用程序的示例类。
IIcResolver通过构造函数注入，然后用它来创建和释放对象。
有几个解决方法的重载可以根据需要使用。Release方法用于释放组件(对象)。
如果你是手动创建一个对象，调用Release方法释放对象非常重要。
否则，你的应用程序会有内存泄漏问题。
为了保证对象被释放，尽可能使用ResolveAsDisposable(就像上面的例子所示)。
它会在using代码块结束的时候自动调用Release方法。

IIocResolver(以及IIocManager)有个 CreateScope 的扩展方法(定义在Abp.Dependency命名空间)来安全的释放所有的解析后了依赖资源。
如下所示：

using (var scope = _iocResolver.CreateScope())
{
    var simpleObj1 = scope.Resolve<SimpleService1>();
    var simpleObj2 = scope.Resolve<SimpleService2>();
    //...
}

在using语句块的最后，所有解析后的依赖资源会自动的释放。
也可以使用 IScopedIocResolver 接口来实现上述操作。你能注入该接口并解析依赖关系。
当你使用的类被释放后，所有被解析的依赖资源也会被自动释放掉。
但是，请小心使用它；例如：如果该类的生命周期很长(如单例模式)，
并且需要解析很多对象，那么它们会一直停留在内存中，直到该类被释放掉。

如果你想直接使用IOC容器(Castle Windsor)来处理依赖关系项，
可以通过构造函数注入 IIocManager并使用它IIocManager.IocContainer 属性。
如果你是在一个静态上下文或不能注入IIocManager，
还有最后一个方法，你可以使用单例对象IocManager.Instance，你可以在任何地方获取到，它无处不在。
但是，在这种情况下你的代码将变得不容易测试。


Abp.Dependency.IocManager.Instance.Register<IExternalAuthConfiguration, CustomExternalAuthConfiguration>();

IocManager.Register<IAbpWebApiConfiguration, AbpWebApiConfiguration>();
IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());

base.IocManager.RegisterAssemblyByConvention(typeof(WebPlatformApplicationModule).GetAssembly());
base.IocManager.Resolve<ApplicationPartManager>().AddApplicationPartsIfNotAddedBefore(typeof(WebPlatformWebCoreModule).Assembly);




//----------------------------------------------------------------------

ABP ASP.NET Core


Startup Template

你可以从Startup Template来创建你的项目，
该模板是一个空置且简单的web项目，它预先集成且配置好一切可以与ABP框架一起运行。


Configuration

为了集成ABP到ASP.NET Core，我们应该在 Startup Class 中做一些配置，如下所示：

public class Startup
{
    public IServiceProvider ConfigureServices(IServiceCollection services)
    {
        //...


        //配置Abp和依赖注入，在最后调用
        return services.AddAbp<MyProjectWebModule>(options =>
        {
            //配置Log4Net(可选的)
            options.IocManager.IocContainer.AddFacility<LoggingFacility>(
                f => f.UseLog4Net().WithConfig("log4net.config")
            );
        });
    }

    public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
    {
        //初始化ABP框架和所有其他模块，这个应该首先被调用
        app.UseAbp();

        //...
    }
}


// Configure Abp and Dependency Injection
services.AddAbpWithoutCreatingServiceProvider<WebPlatformWebHostModule>(
    // Configure Log4Net logging
    options => {
        options.IocManager.IocContainer.AddFacility<LoggingFacility>(
        //f => f.UseAbpLog4Net().WithConfig("log4net.config")
        f => f.UseNLog().UseConfiguration(Configuration)

    );
        //注册外部插件，插件规则见appsettings.json中Plugins
        options.PlugInSources.Add(new AppPlugin());
    }
);


Controllers

在ASP.NET Core中控制器可以是任何类类型。
它没有限制控制器类必须派生自Controller类，以Controller结尾的类默认为是MVC Controller，
例如：ProductController。你也可以使用[Controller]特性添加到任何类上，使该类作为一个控制器。
这就是ASP.NET Core MVC的工作方式。

如果你要使用web层类如：HttpContext或者返回一个视图，
最好的方式是继承 AbpController (该类也是派生自MVC的Controller)，
如果你在创建一个和对象一起工作的API Controller，
你可以考虑创建一个POCO Controller类或者可以使用应用层服务作为控制器，如下所述：


Application Services as Controllers

ABP提供了基础设施来创建应用服务。
如果你想你的应用服务作为控制器暴露给远程客户端(正如前面文档描述的使用[动态WebAPI]，
你可以很容易的实现，只需要在你模块的 PreInitialize 方法中做一个简单的配置，如：

Configuration.Modules.AbpAspNetCore().CreateControllersForAppServices(
    typeof(MyApplicationModule).Assembly, moduleName: 'app', useConventionalHttpVerbs: true);

Configuration.Modules.AbpAspNetCore().CreateControllersForAppServices(currentAssembly, Name);

CreateControllersForAppServices 方法会取得指定程序集并转换该程序集下的所有的应用服务作为 MVC Controller。
你可以使用 RemoteService 特性来 enable/disable 方法，类或者接口。

当应用服务被转换为MVC Controller时，默认路由模板是：/api/services/<module-name>/<service-name>/<method-name> 。
例如：如果ProductAppService中定义了一个方法，那么它的URL会是：/api/services/app/product/create (假设模块名称是app)。

/api​/services​/KB​/PiCollectService​/FindPointRecordsByArchived
/api​/services​/<AbpModule>/<ApplicationService>/<MethodName>

如果 useConventionalHttpVerbs 被设置为 true (默认就是这个)。
那么通过命名约定对于应用服务的方法所使用的HTTP谓词(HttpMethod)会被断定为：


Get：如果方法的名字是以 Get 开头
Put：如果方法的名字是以 Put 或者 Update 开头
Delete：如果方法的名字是以 Delete 或者 Remove 开头
Post：如果方法的名字是以 Post，Create 或者 Insert 开头
Path：如果方法的名字是以 Path 开头


否则 Post 被作为Http谓词的默认设置

你可以使用任何的 ASP.NET Core 特性来改变HTTP方法或者Action的路由(当然，添加ASP.NET Core package的引用是必须的)。

注意：首先，动态WebAPI需要应用服务层的服务类必须实现服务层的接口。
但是对于ASP.NET Core 的集成不是必须的。所以MVC attributes应该被添加到服务类上，即使你实现了该接口。


Filters

ABP为AspNet Core预先构建了一些过滤器，这些过滤器被默认添加到所有控制器的所有的Action上。

Authorization Filter

身份授权认证 和 功能管理 集成了 AbpAuthorizationFilter 过滤器.
你可以在Action或者Controller上使用 AbpMvcAuthorize 特性，在Action执行之前来检查给定的权限是否开启
你可以在Action或者Controller上使用 RequiresFeature 特性，在Action执行之前来检查给定的功能是否开启
你可以在Action或者Controller上使用 AllowAnonymous 特性来进行匿名访问，避免身份以及授权认证检测

Audit Action Filter

审计日志 集成了 AbpAuditActionFilter 过滤器，默认记录所有对Action的请求。
你可以在Action或者Controller上使用特性: Audited和DisableAuditing 来控制是否记录日志。

Validation Action Filter

数据传输对象验证 集成了 AbpValidationActionFilter 过滤器，并且自动为所有Action进行输入验证。
除此之外ABP还内置了validation & normalization。
它也会检查MVC的 Model.IsValid 属性，如果Action的输入有无效的输入值那么它会抛出validation exception。
你可以使在Action和Controller上用特性：EnableValidation和DisableValidation 控制validation。

Unit of Work Action Filter

工作单元 集成了 AbpUowActionFilter 过滤器，
它会在Action执行之前自动开启一个工作单元并且在Action执行完成后完成工作单元(如果没有异常抛出)。
你可以使用特性 UnitOfWork 来控制Action的UOW行为。你也可以使用启动配置来改变所有Action上的默认的工作单元特性设置。

Exception Filter

AbpExceptionFilter 被用来处理来自Controller的Action的异常。它处理并且记录异常信息且返回包裹的响应到客户端。
它仅处理object result，不包括 view result。所以，action返回的任何对象，JsonResult 或者 ObjectResult 将会被处理。
Action返回的任何实现自IActionResult视图或者其他结果类型不会被处理。
最好是使用定义在Microsoft.AspNetCore.Diagonistics package中内置的 UseExceptionHandler 扩展方法来处理视图异常。
可以在方法或者类上面使用 WrapResult和DontWrapResult 特性来改变异常处理和日志行为。

Result Filter

AbpResultFilter 被用来包装Action的返回结果，如果该Action执行成功的话。
它仅对JsonResult，ObjectResult和其它不是实现IActionResult接口对象进行返回结果包装，
如果你的Action正在返回一个视图或者其它结果的类型，它不会进行包装。
在方法或者类上面使用 WrapResult和DontWrapResult 特性可以enable/disable包装。
你可以在启动配置里面对包装结果的默认行为进行更改。

缓存Ajax请求结果

对于Ajax请求，AbpResultFilter 会添加 Cache-Control 头 (no-cache, no-store...) 到响应结果。 
因此，对于AJAX请求，它会阻止浏览器缓存响应结果，甚至对于Get请求也一样。通过配置或者特性，你可以禁用该行为。
你可以使用 NoClientCache 特性来阻止缓存(这是默认行为)或者使用 AllowClientCache 特性来允许浏览器缓存结果。
或者，为了更好的自定义控制，你可以扩展 IClientCacheAttribute 接口来实现指定特性。

Model Binders

AbpDateTimeModelBinder 被用来标准化输入时间(可空类型的时间)，
实际是调用 Clock.Normalize 方法来实现该功能。


//----------------------------------------------------------------------





